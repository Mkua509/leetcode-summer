---
title: "Invert-Binary-Tree"
question_id: "226"
question_link: "https://leetcode.com/problems/invert-binary-tree/description/"
difficulty: "Easy"
---

1. We are given the root of a binary tree

2. We are told to return the inverse of a tree but only the root

This is a pretty simple question I learnt through mecheng 270 (I did so bad in this course), that we are able to do reversal through a concept called recursion.

Essentially how recursion works which I personally never fully wrapper my head around difficult recursions is that it will recall itself in the function essentially preforming a constant loop over and over again until the process is complete.

In this case because each binary tree essentially has a subtree over and over again we can just swap the root.left to be root.right and vice versa and run recursion, because it will go down the list and invert every single subtree until there isn't any left pretty cool and nice and super super simple yipee.

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def invertTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: Optional[TreeNode]
        """
        if not root:
            return None

        root.left, root.right = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)

        return root
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`