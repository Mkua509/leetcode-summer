---
title: "Kth Smallest Element BST"
question_id: "230"
question_link: "https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/"
difficulty: "Medium"
---

1. We are given the root to a BST and an integer called k
2. Return the kth smallest value in the BST

When we use DFS on an BST the values returned will always be in order. This means we are able to use this to our advantage, essentially all we have to do is set an counter and iterate through the BST until we reach the end of the counter, once we reach the end of the counter we know that the current value is the kth smallest value.

Once again DFS can be done using recursion, by first checking the root node to see if the current value exists or not and then rerunning DFS on the left of the current node, then reducing the count. If the current count is == 0 then we can stop and return the result otherwise check the right side using DFS. This would ultimately lead to the final value being the result of the kth value.


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def kthSmallest(self, root, k):
        """
        :type root: Optional[TreeNode]
        :type k: int
        :rtype: int
        """

        count = [k]
        result = [0]

        def dfs(node):

            if not node:
                return
            
            dfs(node.left)
            count[0] -= 1

            if count[0] == 0:
                result[0] = node.val
                return
            
            dfs(node.right)
        
        dfs(root)
        return result[0]
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`