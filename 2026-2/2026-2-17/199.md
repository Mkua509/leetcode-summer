---
title: "Binary Tree Right Side View"
question_id: "199"
question_link: "https://leetcode.com/problems/binary-tree-right-side-view/"
difficulty: "Medium"
---

1. Input is the root of a binary tree
2. Imagine yourself standing on the right side of the tree, return the **values** of the nodes you can see ordered from top to bottom in a list. (Basically items in your line of vision)

This question we can use BFS to solve it as we can go through each level to see which value is on the right most of the tree. 

The same as yesterday's question where we have to essentially begin with a queue and a result, we check if there is anything inside the tree in the first place and if there isn't it will return an empty list. Then we setup 

Otherwise we want to append the root node into the empty queue and begin the process, while there is an object in queue set up an for loop that runs for the length of the current level, for each level add the current nodes none empty children into the queue and once we reach the end we know that we are on the outermost node of the level to the right, so we append that value to result this will complete the loop (We do this by using the index from the for loop where if the index == the length of level - 1). Then the while loop runs again until all values in the tree has been touched.

Finally we return

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution(object):
    def rightSideView(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[int]
        """

        queue = []
        result = []

        if root is None:
            return result
        
        queue = deque()
        queue.append(root)

        while queue:
            level_size = len(queue)
            for i in range(level_size):
                current_node = queue.popleft()
                if i == (level_size - 1):
                    result.append(current_node.val)
                if current_node.left:
                    queue.append(current_node.left)
                if current_node.right:
                    queue.append(current_node.right)
        
        return result
```
If we use standard list pop(0) the worst time complexity will be O(n^2) as it would have to traverse through the list deque is best used for FIFO with queue behavior and normal queue for stack.

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`