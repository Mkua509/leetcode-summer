---
title: "Lowest Common Ancestor of a Binary Search Tree"
question_id: "235"
question_link: "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/"
difficulty: "Medium"
---

1. Given a BST find the lowest common ancestor node of two given nodes `p` and `q` in the BST
2. Return the lowest common ancestor (A node is able to be a descendent of itself as well)

We could probably use depth first search once again to determine the lowest common ancestor the most simple method is probably by searching through the tree using depth first search and finding the values in the tree that match with p and q but store the smallest value every time a smaller value appears until we reach p and q. Once that happens we know that the is the smallest value and can thus return it in linear time. I think...

Wait i'm wrong, the more I thought about it the more I realized why first consider because its a BST all values in the left sub tree will be smaller then the current node and vice versa. This allows us to not have to use DFS without looking through the entire tree. My previous idea was incorrect BECAUSE the LCA is not necessarily the smallest value because a node is able to be a descendent of itself.

There are three cases to consider then:

1. When `p` and `q` are smaller then the current value meaning `p` and `q` are on the left sub tree
2. When `p` and `q` are larger then the current value meaning `p` and `q` are on the right sub tree
3. Otherwise `p` and `q` one is on the left and one is on the right OR current is equal to `p` or `q` then the current node is LCA

Basically the LCA is the first node where p and q split apart

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        
        current = root

        while current:
            if p.val < current.val and q.val < current.val:
                current = current.left
            elif p.val > current.val and q.val > current.val:
                current = current.right
            else:
                return current
```

> Time Complexity : `O(1)`
> 
> Space Complexity : `O(h)`