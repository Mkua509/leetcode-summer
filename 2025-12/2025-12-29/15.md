---
title: "3Sum"
question_id: "15"
question_link: "https://leetcode.com/problems/3sum/description/"
difficulty: "Medium"
---

We are given an array of numbers and asked to return an output of all the triplets that add to 0 without any duplicates inside...

how do i start? what do i do I honestly am not sure buuut what if we think about this in the context of the worst way of completing it?

We could technically sort the list then go through the list starting from the start and then iterating through it one number at a time until we find three numbers that add together to turn into 0, but this would create a time complexity of around O(n^3), create a set btw since no duplicates, then we can convert back to tuples into a list of lists then return the final results.

Obviously extremely inefficient, but I get some clues as this is essentially a sort and two pointer question. By sorting we can avoid duplicates and allows the left and right pointers to move in a pretty predictable way. We first fix a number lets say `number_1` and then we place two pointers `left` and `right` if current sum is too large move the `left` pointer upwards and opposite if its too small, when the sum is zero we record the current triplet and skip any duplicate values.

Some things to consider if all the numbers from start to finish is all positive its not possible for the values to sum to 0. Well if the value we are currently on is the same as the previous one we skip it which prevents duplicates.

After finding a valid triplet we need to move both pointers inward because keeping both pointers could cause reusing of the same values and cause duplicates or inf loops. Since the sum is already correct, moving both would basically make sure that we are searching for new paires.

```python
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        results = []
        nums.sort()

        for i, a in enumerate(nums):
            if a > 0:
                break

            if i > 0 and a == nums[i - 1]:
                continue
        
            left = i + 1
            right = len(nums) - 1

            while left < right:
                threesum = a + nums[left] + nums[right]

                if threesum > 0:
                    right = right - 1

                elif threesum < 0:
                    left = left + 1
                else: 
                    results.append([a, nums[left], nums[right]])
                    left = left + 1
                    right = right - 1
                    while nums[left] == nums[left - 1] and left < right:
                        left = left + 1
        return results
```

> Time Complexity : `O(n^2)`
> 
> Space Complexity : `O(m)`