---
title: "Trapping-Rain-Water"
question_id: "42"
question_link: "https://leetcode.com/problems/trapping-rain-water/description/"
difficulty: "Hard"
---

My first leetcode hard question... Trapping rain water is similar to the question I did yesterday and is under the two pointers category. 

1. Input we are given a `n` non-negative integers representing an elevation map where the width of each bar is `1` essentially its a block and the height is 1 with each number. We need to find a way to calculate all the possible areas where water can be stored.

2. The output is therefore how much water can be trapped after raining in total in units

3. So how do we do this? We need to find a effective method of finding area since lets say the shape is anything but a straight square or rectangle we will have to use addition in those cases. My first thought is if we run through the entire thing by levels, and calculate the area of that level and add it to the layer below.

wait its not calculating area its calculating units I forgot, that makes it a bit easier to work with although still difficult.

But that would be super inefficient and annoying to code. So I wonder if there is a more efficient way of doing it? Since each box is already a square perhaps we can take what we used yesterday and put a twist on it. We can understand that water at any position is completely dependent on the smallest height on either side, because it will always overflow on the shortest end. So with knowing that we are able to move the shorter sides pointer inwards and calculate the current places water. The equation for that would be currentmaxwall_height(on smaller side) - current_height(On smaller side) = water unit on pointer

because we are using pointers therefore we would only have to traverse once through he entire list creating O(n) complexity which should be pretty good heheheh

```python
class Solution(object):
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        # Checks if there is an exisiting value in list first
        if not height:
            return 0
        
        left, right = 0, len(height) - 1
        maxleft, maxright = height[left], height[right]
        result = 0

        while left < right: 
            if maxleft < maxright:
                left += 1
                maxleft = max(maxleft, height[left])
                result += maxleft - height[left]
            else: 
                right -= 1
                maxright = max(maxright, height[right])
                result += maxright - height[right]

        return result
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`

I can't believe I was able to make it pass after a bit of tweaking, it was surprising that I was able to do this leetcode hard but I suspect its one the easier side of hards. The main thing to remember with it is that the result was difficult for me to grasp at first but I needed to think at a much deeper level, in principle the coding part is not the hard part. But the problem solving oh man, i kept misinterpreting stuff so it screwed with the amount of time it actually took.

Do not be fooled by the amount of text it took me like an hour and a half to solve this question. But what a way to end the year see you on 2026 !!!