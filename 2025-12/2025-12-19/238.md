---
title: "Product-Of-Array-Except-Self"
question_id: "238"
question_link: "https://leetcode.com/problems/product-of-array-except-self/"
difficulty: "Medium"
---

Okay so lowkey I really wanted to be dumb and try with the division even thought the question explicilty states not to. It's not because I didn't read the question okay? I just thought that if i implemented it with division it might help me understand the question a bit more and I think I might have an idea how to solve it. But first let me run you through what I did. 

1. Simple stuff initialized a empty result list for the result (hehehaha)
2. Ran through the list based on length
3. Made x = 1 (I made it 0 and realized it wouldn't work cause everything will just be = 0 and break when I divide lol)
4. Nested loop in order to run through every single number in the list `nums` ofcourse this is gonna be `O(n^2)` so its not even optimal in the first place (I love nested loops it makes the time complexity so easy to understand ^ - ^)
5. Just times x by x to find product 
6. Divide (floor division won't work it'll output wrong number)
7. Append x to the end of the `result` list
8. return `result`

```python
class Solution(object):
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        result = []
        for i in range(len(nums)):
            x = 1
            for j in range(len(nums)):
                x = x * nums[j]
            x = x/nums[i]
            result.append(x)
        return result

```

> Time Complexity : `O(n^2)`
> 
> Space Complexity : `O(n)`

Wowowow what a lovely and simple set of code now you might ask what to do about the division? Honestly IDK but I have this idea that I picked up during one of my coding courses (I did so bad in that :sob: atleast I learnt something) Basically what if we make the current number the pivot and whatever is left and right of it we create a left hand side and right hand side. Times both sides seperatly and times it again at the end?

conceptually it should be like this (I should lowkey do this more "conceptually ðŸ¤“"):

```python
nums = [a, b, c, d]

pivot at nums[i] (lets say currently at b):
left = a
right = c * d
result = left * right
```

But how do I prevent this from becoming a O(n^2) run time again (Ah what a nightmare i'm def failing a techincal interview)... I need to figure a way to make it so we don't have to constantly be recomputing left/right everytime so we only store it once.

We are able to do this by first filling result[i] with the products of all the elements to the left of current index then we can mutiply every result[i] with the product of the elemts to the right of index. Honestly I needed some help with the implementation but my idea was correct. The main takeaway from this is just thinking of different ways to decrease the time complexity of the question down to O(n).

1. Creates a list that is the same length as `nums` where each element is `1` because `1` will be the base number that we mutiply with everything
2. Fill with `left` products by keeping a product of all elements to the left of `index` for each `index` it stores in `result` after this loop all items in list will be equal to product of all numbers before the current `index`
3. Do the same thing for the `right` but this time the current `result` will already include the products of everything `left of index` so once this process is completed the `result` list will be filled with all product numbers excluding multiplying `index`
4. Finally return

I went to the beach today (4 hour total drive) so tired lowkey busy week or else I would like to have been doing more leetcode everyday but legit going out every day for the next few days.

```python
class Solution(object):
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        length_nums = len(nums)
        
        # Create a list of 1s in a length of numbers
        result = [1] * length_nums

        # left side of pivot value
        left = 1
        for i in range(length_nums):
            result[i] = left
            left = left * nums[i]
        
        # Right side of pivot values
        right = 1
        # range(start, stop, step)
        for i in range(length_nums - 1, -1 , -1):
            result[i] = result[i] * right
            right = right * nums[i]
        
        return result
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`
