---
title: "Best-Time-to-Buy-and-Sell-Stock"
question_id: "121"
question_link: "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"
difficulty: "Easy"
---

1. Input given is an array called `prices` where `prices[i]` is the price of a given stock on the `i` day

2. The return value is the maximum profit we can gain by buying a stock on one day and then choosing a different day to sell that stock, return maximum profit you can achieve from this transaction. If there is no profit, return `0`

3. First thoughts is we need to check through the entire list to see where the biggest difference between two values are, this would indicate that this is the highest amount of profit we are able to gain, this would only work left to right however because we are not allowed to buy in the future and sell in the past.

I can try a brute force method for this first and then deal with a more effective one after. Essentially we can just check through the entire list find the smallest value to the left side and then minus the values on the right.

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        if not prices:
            return 0
        
        left, right = 0, len(prices) - 1

        result = 0

        while left < right:
            temp_right = right
            for i in range(temp_right - left):
                result = max((prices[temp_right] - prices[left]), result)
                temp_right -= 1
            left += 1
        
        return result                       
```

Okay this is def a O(n^2) problem just looking at it, but at least I got the brute force out of the way. I ran into one issue was originally my result = max line was calculating the buy value - sell value. This calculated wrongly, its supposed to be sell value - buy value = result this would essentially mean that we are always assuming that the sell value will be more in most cases. 

ITS TOO SLOW I JUST RAN IT TIME LIMIT EXCEEDED :sob: 198/212 test cases lol

> Time Complexity : `O(n^2)`
> 
> Space Complexity : `O(1)`

What if I use a two pointer method instead... I already technically started doing that but I think I got lost on the way. The way we have to think about it for two pointer is left is the buy day well right is the sell day. If the price at right is higher then left then a profit is possible so we update the result, else if the price is lower then left then the right becomes the new left because a cheaper buying price is always better. We don't start from the end of the list but the start of the list too.

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        left, right = 0, 1
        maxProfit = 0

        if not prices:
            return 0

        while right < len(prices):
            if prices[right] > prices[left]:
                maxProfit = max(maxProfit, prices[right] - prices[left])
            else:
                left = right
            right += 1
        
        return maxProfit
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`

Well I didn't really want to do this but because its in the sliding window section of the neetcode 160 I guess i have to learn sliding window :smile: the way to think about this question is how do we do this with linear time? How do we make it so that we don't have to check every single value in the entire list multiple times? 
We need to optimize this so that its O(n) by tracking the minimum price so far and updating the max profit in one pass. So the goal would be to find the smallest value on the left and the largest value on the right. As long as these two values are in left to right order.

First what is a sliding window? Its a algorithm that optimizes solutions with nested loops with O(n^2) complexity into a single pass approach which is linear time complexity O(n) this is done by avoiding any redundant calculations.

How does it work? There is two types of sliding windows a fixed and a dynamic.

1. Fixed is when the window size is known and its used to find subarrays or substrings of a fixed length

2. Dynamic is something that expands and shrinks and applies to questions which ask us to find the longest or shortest subarray/substring that satisfied a condition

The most likely use case for this question is the dynamic version. Where as we keep track of the lowest buy price and the maxprofit. Each time we go through the list we see if todays price is the lower then the lowest buy price, and if it is we replace it. If not then we calculate the difference and see if its smaller then the maximum profit. This would make it linear time in one simple pass.

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        
        if not prices:
            return 0

        minPrice = prices[0]
        maxProfit = 0

        # Sell in for sell in prices: is the value at the current index not the index
        for sell in prices:
            maxProfit = max(maxProfit, sell - minPrice)
            minPrice = min(minPrice, sell)
        
        return maxProfit
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`