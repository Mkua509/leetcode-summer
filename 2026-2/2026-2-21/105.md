---
title: "Construct Binary Tree from Preorder and Inorder Traversal"
question_id: "105"
question_link: "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
difficulty: "Medium"
---

1. We are given an inorder and preorder traversal list
2. Reconstruct the binary tree based off that

preorder = [3,9,20,15,7] Where it's based off root -> left node -> right node
inorder = [9,3,15,20,7] Where it's based off left -> root -> right

There are two main things to remember

1) The value at preorder[0] will always be the root node in the tree (Or sub tree)
2) Any value to the left of inorder.index(preorder[0]) determines the nodes.left while any value to the right determines the node.right

If we consider these two facts we are able to use recursion to reconstruct a binary tree.

Firstly we want to set a base case where there is no values in either lists, this would return None.

After that we set the first value inside the the preorder as the root node. After we do that we have to set a middle value this middle value is essentially the pointer which points to the current root node of the sub tree.

So let's say the current root is = 3 then in the inorder the index of 3 will be 1. That is the middle value, the reason we do this is so that we can use inorder to determine what the values to the left and right of the current node is.

We then run recursion for the left value (based off normal Binary Tree properties), we essentially make the preorder list move forward to the next sub-lists root node and then find all the values before the current root node in the inorder list (this allows us to determine the items in the left of the tree).

We then run recursion for the right values it's the same concept but now we want to move the preorder values to everything after the mid value (not including the middle value). The same applies for inorder where all the values to the right of mid are now what we look for.


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: Optional[TreeNode]
        """
        
        # Base case
        if not preorder or not inorder:
            return None
        
        # The first value of preorder traversal iwll always be the root
        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])
        root.right = self.buildTree(preorder[mid+1:], inorder[mid + 1:])
        return root
```

> Time Complexity : `O(n^2)`
> 
> Space Complexity : `O(n)`