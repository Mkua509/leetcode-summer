---
title: "Koko-Eating-Bananas"
question_id: "875"
question_link: "https://leetcode.com/problems/koko-eating-bananas/"
difficulty: "Medium"
---

What a ridiculous question. How does this have anything to do with binary search?

I legit can't even wrap how to start this question but lets first work through the inputs and outputs.

1. Two inputs:

- `piles` an integer list containing integers of te amount of bananas per pile e.g. `n` piles of bananas, the `ith` pile has `piles[i]` bananas. 

- `h` hours, which the guards will come back in `h` hours

3. The output is the __minimum__ integer `k` such that Koko the monkey can eat all the bananas within `h` hours

Okay first we can look at a edge case. Essentially I noticed a pattern where if the length of the list and the hours is the same size the min value will always be the largest value in `piles` which makes sense, so we can just calculate it easily.

This also gives a hint of the true list we should be binary searching, which is not `piles` but the total amount of different ways we can eat a banana. This is because we know that the maximum most efficient number would be the max number inside `piles`, so for example if the list was:

piles = [1,3,3,20,5,6] and h = any number

we can deduce that the number that would be the highest and still efficient without excess eating rates is 20, meaning we can assume 1, 2, 3, 4, 5, 6, n+1.... 20 is the maximum and it will already be sorted. So the answer will be within that range of numbers.

Then perhaps we check through the numbers starting from 1 and see if its able to finish before the hour is up, if not then its False, as soon as the first True comes out we know that the value is the min value possible to complete the piles.

```python
class Solution(object):
    def minEatingSpeed(self, piles, h):
        """
        :type piles: List[int]
        :type h: int
        :rtype: int
        """
        left, right = 1, max(piles)
        result = 0
        
        while left <= right:
            # Current value is basically mid
            current_speed = (right + left) // 2
            total_time = 0
            for pile in piles:
                # Need to force float division
                total_time = total_time + (math.ceil(float(pile) / current_speed))
            if total_time <= h:
                result = current_speed
                right = current_speed - 1
            else: 
                left = current_speed + 1
        
        return result
```

> Time Complexity : `O(n log m)`
> 
> Space Complexity : `O(1)` 

I couldn't really figure out the math of it until I really thought about it but it makes sense now, we essentially want to go through each different value that could work and divide the current pile by that number to see how much time it takes to complete that pile, then we just add it to total_time for all the piles.