---
title: "Permutation-in-String"
question_id: "567"
question_link: "https://leetcode.com/problems/permutation-in-string/description/"
difficulty: "Medium"
---

1. What exactly is the input? It is two strings `s1` and `s2` which only consist of lowercase English letters

2. The return is a boolean `true` or `false` you return `true` if one of `s2` contains a permutation of `s1` meaning a rearrangement of all characters in a string. otherwise `false`.
this means that if one of `s1`'s permutations is the substring of `s2` then return `true`

3. Things to understand `s2` substring needs to be a non broken up permutation of `s1` so it must be a straight line.

How can we check if one string is a permutation of another string? One of the ways is to sort the string and compare but this would result in a high time complexity.

What if instead we take a look at small chunks of `s2`'s string and use hash tables to check if the window contains the same amount of characters as the `s1` value there should exactly be a array of size 26 because there is 26 characters in the alphabet.

Another way of thinking about it is by using sliding window we know that by using a dynamic sliding window array we can check if `s2` contains the characters from `s1` to do this we understand that the maximum size of the window should be the size of `s1` because the permutation would never exceed that size. There should be two arrays one for `s1` and another for the current window in `s2`. If these two arrays match then the window is a valid permutation, as we slide the window forward, we update the counts by removing the left character and adding the new right character. This makes the algorithm very effective as it looks through everything at most once.

```python
class Solution(object):
    def checkInclusion(self, s1, s2):
        if len(s1) > len(s2):
            return False

        s1Count, s2Count = [0] * 26, [0] * 26

        for i in range(len(s1)):
            s1Count[ord(s1[i]) - ord('a')] += 1
            s2Count[ord(s2[i]) - ord('a')] += 1

        matching = 0
        for i in range(26):
            if s1Count[i] == s2Count[i]:
                matching += 1

        left = 0
        for right in range(len(s1), len(s2)):
            if matching == 26:
                return True

            # add right character
            idx = ord(s2[right]) - ord('a')
            s2Count[idx] += 1
            if s1Count[idx] == s2Count[idx]:
                matching += 1
            elif s1Count[idx] + 1 == s2Count[idx]:
                matching -= 1

            # remove left character
            idx = ord(s2[left]) - ord('a')
            s2Count[idx] -= 1
            if s1Count[idx] == s2Count[idx]:
                matching += 1
            elif s1Count[idx] - 1 == s2Count[idx]:
                matching -= 1

            left += 1

        return matching == 26

```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`