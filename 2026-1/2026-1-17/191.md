---
title: "Number-Of-1-Bits"
question_id: "191"
question_link: "https://leetcode.com/problems/number-of-1-bits/description/"
difficulty: "Easy"
---

There is a naive approach to this which is quite literally count the number of 1's but i'm like 100% sure its not the most optimal way of counting bits. 

1. Input is a positive integer n which is converted to binary representation 

2. Count the amount of times that 1 appears

In bit counting there is a algorithm called the Brian Kernighan algorithm it essentially iteratively unset's the rightmost set bit until the number becomes zero, counting through each iteration. Essentially whenever you subtract 1 from a number n all bits after the rightmost set bit are flipped, including the rightmost set bit itself (from 1 to 0). When you preform a bitwise AND (&) operation between n and n-1 all bits to the right of original rightmost set bit will be 0 in both numbers, so their AND result is = 0. The original rightmost set bit is 1 in n and 0 in n - 1. so its AND result is also 0. The bits to the left remain unchanged. 

The result is that the rightmost '1' bit is effectively removed and we just count eac iteration of that.

```python
class Solution(object):
    def hammingWeight(self, n):
        """
        :type n: int
        :rtype: int
        """
        counts = 0
        while n:
            n &= (n-1)
            counts += 1
        return counts
```

> Time Complexity : `O(k)` Where k is number of set bits
> 
> Space Complexity : `O(1)`