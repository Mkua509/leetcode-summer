---
title: "Validate-Binary-Search-Tree"
question_id: "98"
question_link: "https://leetcode.com/problems/validate-binary-search-tree/description/"
difficulty: "Medium"
---

1. They enter a root of a binary tree
2. We must determine if it is a valid BST by returning True or False

__A Valid BST__ is defined as follows:

- The left subtree of a node contains only nodes with keys strictly less than the node's key
- The right subtree of a node contains only nodes with keys strictly greater than the node's key
- Both the left and right subtrees must also be binary search trees

The main thing to note is that the left subtree values must be smaller then the current node value and the right sub tree value must be greater then the current subtree values. We can use a DFS + Recursion approach to tackle this problem.

One important property of a BST is not just if a value is smaller or larger, __every node must fit within a valid value range decided by all its ancestors__. This essentially means as we go down the tree to the left as the values get smaller it must satisfy that all of the values is smaller then the current value.

- When we move left in the tree the value must be less then the parent thus the upper bound becomes smaller
- When we move right in the tree the value must be greater then the parent thus the lower bound increases

As we move down the bounds will tighten more and more and if any nodes is not within this range we know that it is not a valid BST.

One other main point to worry about is that the root is within an initial range of (-inf, inf).


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isValidBST(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        def valid(node, left, right):

            if not node:
                return True
            
            if not (left < node.val < right):
                return False
            
            return valid(node.left, left, node.val) and valid(node.right, node.val, right)
        
        return valid(root, float("-inf"), float("inf"))
            
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`