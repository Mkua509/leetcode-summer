---
title: "Search-2D-Matrix"
question_id: "74"
question_link: "https://leetcode.com/problems/search-a-2d-matrix/description/"
difficulty: "Medium"
---

1. Input given is first a `target` integer to find and a `m x n` integer matrix `matrix` with properties:

- Each row is sorted in non-decreasing order
- The first integer of each row is greater than the last integer of previous row

2. Return `True` if value exists `False` otherwise


I have a amazing idea for this since binary search works on 1D arrays really well what if we first combined all the matrix lists into one big list (IDK how to do that i'll just search it up) and then we just run binary search? 

I'm like 90% sure it'll work. But how do we combine the list? Well apparently its called flattening, and we can do it by essentially making a empty list, and then running a for loop and using list.extend(sub lists) where the sub lists is the values we draw from the matrix.
```python
class Solution(object):
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        
        # Use flattening to combine all lists into one first
        combined_list = []
        for sublists in matrix:
            # Extend adds elements from an iterable to the end o current list
            combined_list.extend(sublists)
        
        # Now we use binary search on the flattened list
        left = 0
        right = len(combined_list) - 1
        while left <= right:
            mid = (left + right) // 2

            if combined_list[mid] == target:
                return True        
            elif combined_list[mid] <= target:
                left = mid + 1          
            else:
                right = mid - 1
        
        return False
```

> Time Complexity : `O(mn * log(mn)) = O(mn)`
> 
> Space Complexity : `O(mn)`

The above is not the most optimal solution however because the leetcode question asks that we solve it in O(log(mn)) time complexity, the main thing to consider in order to achieve that time complexity is how we consider the matrix as a already sorted list instead of attempting to flatten the list first. So we need to work with the matrix by itself.