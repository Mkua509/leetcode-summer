---
title: "Subtree-of-Another-Tree"
question_id: "572"
question_link: "https://leetcode.com/problems/subtree-of-another-tree/description/"
difficulty: "Easy"
---

1. Given the roots of two binary trees `root` and `subRoot` 
2. return `true` if there is a subtree of `root` with same structure and value as `subRoot` and return `false` otherwise

We want to first walk through the entire tree using DFS to see if the current node we are on has the same value as the start of the subtree.

If we go through the entire tree and it doesn't then we can automatically assume its False:

- If the value matches the root we compare both subtrees fully
- If they are identical then subRoot is a subtree and we return True
- Otherwise continue searching on the left and right children

We should create a helper called sameTree to check if the two tree's are exactly the same node-for-node

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSubtree(self, root, subRoot):
        """
        :type root: Optional[TreeNode]
        :type subRoot: Optional[TreeNode]
        :rtype: bool
        """

        if not subRoot:
            return True
        if not root:
            return False
        
        if self.sameTree(root, subRoot):
            return True
            # Compare the left or right roots to the start of subRoot
        return (self.isSubTree(root.left, subRoot) or self.isSubTree(root.right, subRoot))

    def sameTree(self, root, subRoot):
        if not root and not subRoot:
            return True
        if root and subRoot and root.val == subRoot.val:
            return(self.sameTree(root.left, subRoot.left) and self.sameTree(root.right, subRoot.right))
        return False
```

> Time Complexity : `O(mâˆ—n)`
> 
> Space Complexity : `O(m+n))`