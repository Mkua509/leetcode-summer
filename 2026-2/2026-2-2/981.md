---
title: "Time-Based-Key-Value-Store"
question_id: "981"
question_link: "https://leetcode.com/problems/time-based-key-value-store/description/"
difficulty: "Medium"
---

The core idea of this question is to implement a time-based key-value data structure that supports:

- Storing multiple values for the same eky at specified time stamps
- Retrieving the key's value at a specified timestamp

In order to do this we need to implement the `TimeMap()` class:

- `TimeMap()` Initializes the object
- `void set(String key, String value, int timestamp)` stores the key with the value at the given time `timestamp`
- `String get(String key, int timestamp)` Returns the most recent value of key if set was previously called on it and the most recent timestamp for that key prev_timestamp is less then or equal to the given timestamp (`prev_timestamp <= timestamp`). If there are no values, return `""`

Important note: all calls to `set` the timestamps are strictly increasing order

Seems to be a systems design question, i'm actually horrible at this type of question so I guess i'll focus a lot on the learning aspect of it.

The best way to think of this is this:

| Key    | Values <time, val> |
| -------- | ------- |
| "foo"  | [["bar",1]]|

So in this case set for the above example would be ["foo", "bar", 1], while the get for that value is ["foo", 1] so when we do get we are essentially going through the list of values with that key to find the value that has the time stamp. But if nothing has a time stamp of the one your trying to get e.g. get ["foo", 3] just return the most recent time that is less then 3, e.g. 1 in this case since its closest to 3.

Set will always be O(1) because if we will be using a hashmap. 

The problem occurs when there is more then one item in the hashmap:

| Key    | Values <time, val> |
| -------- | ------- |
| "foo"  | [["bar",1], ["bar2", 4]]|

We now must consider how to search through the times effectively, if we do it by brute force the value would be O(n) which by itself is not inherently bad. But there is a possible way of getting it to be O(log n), because of the one hint they gave us in the constraints! it stated that all calls to `set` the timestamps are strictly increasing order. So we can immediately conclude that it is sorted and thus we can use binary search on the time values.

```python
class TimeMap(object):

    def __init__(self):
        self.store = {} # key : value=[list of [value, timestamp]]
        

    def set(self, key, value, timestamp):
        """
        :type key: str
        :type value: str
        :type timestamp: int
        :rtype: None
        """
        if key not in self.store:
            self.store[key] = []
        self.store[key].append([value, timestamp])

        

    def get(self, key, timestamp):
        """
        :type key: str
        :type timestamp: int
        :rtype: str
        """
        result = ""
        values = self.store.get(key, [])

        # Binary search

        left, right = 0, len(values) - 1
        while left <= right:
            middle = (left + right) // 2
            if values[middle][1] <= timestamp:
                result = values[middle][0]
                left = middle + 1
            else:
                right = middle - 1

        return result
        

# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)
```

> Time Complexity : `O(log n)` for set() and `O(log n) for get()
> 
> Space Complexity : `O(m * n)`