---
title: "Count Good Nodes in Binary Tree "
question_id: "1448"
question_link: "https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/"
difficulty: "Medium"
---

1. Input is the root of a binary tree
2. Output is the count of good nodes

The definition of a good node is when a node is larger then any of it previous nodes. I decided to use BFS (Breadth First Search) to complete this question. However this is probably the least effective method because I realized once I finished making the answer DFS would have been easier especially with anything to do with __paths__. 

But anyways the way BFS works is that it works through each different level and keeps a individual max previous value by using pairs where we store the (value of current node, maximum previous node). In this case we can work through each level and check if the current value is the maximum out of the path, if it is we then add to the overall count.

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def goodNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        # Input binary tree root, 
        # Return the number of good nodes 
        # Each path needs it own maximum so keep value pairs
        from collections import deque

        count = 0

        if root is None:
            return count

        queue = deque()
        queue.append((root, root.val))

        while queue:
            current_node, max_node = queue.popleft()
            if current_node.val >=  max_node:
                count += 1
                max_node = current_node.val
            if current_node.left:
                queue.append((current_node.left, max(current_node.val, max_node)))
            if current_node.right:
                queue.append((current_node.right, max(current_node.val, max_node)))
        return count
                
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`

I might try implement it using DFS too it's just easier in general. Because we can just go down the path and check if any previous value was larger then the current value. 

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def goodNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        # Input binary tree root, 
        # Return the number of good nodes 
        # Each path needs it own maximum so keep value pairs
        
        def dfs(self, maxVal):
            if root is None:
                return 0

            if node.val >= max_value:
                result = 1
            else:
                result = 0
            max_value = max(node.val, max_value)
            result += dfs(node.left, max_value)
            result += dfs(node.right, max_value)
            return result

        return dfs(root, root.val)
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`
