---
title: "Two-Sum"
question_id: "1"
question_link: "https://leetcode.com/problems/two-sum/description/"
difficulty: "Easy"
---

Its the infamous two sum! I've probably redone this question like a billion times but lets see if I remember how to do it.

I'm gonna use a brute force method first and then afterwards work into enumeration and hash maps since I do remember that being one of the best methods.

1. Brute force method involves nested loops going through the list with index `i` and index `j` (Which one step ahead of index i) and adding values until you find the correct target value, then output the index of the combination values. It was pretty easy to implement, however one caveat I ran into was that my python must be super rusty cause I did.

```python
for j in range(len(nums) + 1)

# Instead of the below 

for j in range(i+1, len(nums)):
```

Its a minor but annoying mistake that I didn't like that I made, I guess its why i'm doing this in the first place essentially what the first python output would do is it would add one to the length of the array `nums` instead of starting from one forward of index `i`. 

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        index = []
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] + nums[j] == target:
                    index.append(i)
                    index.append(j)
        return index
```

> Time Complexity : `O(n^2)`
> 
> Space Complexity : `O(1)`

2. `enumerate` python function essentially adds a counter to an iterable and returns it as a enumerate (one by one) object, in a tuple of `(index, value)`. This simplifies loops by providing both the position and item simultaneously. The rest of the code works by using hash maps, essentially it will store a previous seen value in a dictionary and enumerate through the list, if the `target - value` is inside of a previous seen value then its returns

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevHash = {} # Value : Index

        for index, num in enumerate(nums):
            diff = target - num
            if diff in prevHash:
                # Returns the index and which diff exists and current index
                return [prevHash[diff], index]
            # Stores two values into the hashmap value and key
            prevHash[num] = index
        return
```