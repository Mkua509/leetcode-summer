---
title: "Reorder-List"
question_id: "143"
question_link: "https://leetcode.com/problems/reorder-list/"
difficulty: "Medium"
---

This question was actually really annoying the main issue with pointers and linked lists for me is that I get completely lost even though the process is completely the same. I need to learn some rules and today I did end up learning something.

Rules I learnt:

 - When you want to change something the temp value will always be the value that is next from the current value
 - The Tortoise and the Hare actually appears a lot when dealing with linked list so its good that i'm familiar with it (sort of)

 1. The input is a singly-linked list
 2. Output should be the singly-linked list ordered in the pattern [0, n, 1, n-1, 2, n-2...]

The brute force method of this would essentially save the second half of the linked list as a separate list and reversing it then adding it back to the list. This would however make the entire process less space effective.

If we use the fast and slow approach we can make the space complexity O(1) because we don't actually have a extra list we are just replacing the old list. The process is like this we initially set the fast and slow up and make it iterate through it until fast reaches the very end at this point the slow pointer will be exactly half of the entire list. We can then create a new variable setting the head of the second half and create a previous pointer cutting off the previous half.

Once that is competed we can iterate through the second half and reverse it using normal reversal methods, then we can combine the list. Because we now have a previous pointer which was used for reversing the list we can iterate backwards from the second list and move forward in the first list and replace.

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reorderList(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: None Do not return anything, modify head in-place instead.
        """
        
        # Fast and slow approach but first split the list in half

        fast, slow = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next 

        second_half = slow.next
        # We need to disconnect the previous half
        prev = slow.next = None

        while second_half:
            temp = second_half.next
            second_half.next = prev
            prev = second_half
            second_half = temp
        
        first, second = head, prev
        while second:
            temp1, temp2 = first.next, second.next
            first.next = second
            second.next = temp1
            first, second = temp1, temp2
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`