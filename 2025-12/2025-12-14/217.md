---
title: "Contains-Duplicate"
question_id: "217"
question_link: "https://leetcode.com/problems/contains-duplicate/"
difficulty: "Easy"
---

Leetcode journey grind starts today! YAY

Contains duplicate is a repeat of a leetcode question i've done before, it requires us to look through a integer array of `nums`, and return `True` if a value appears twice inside the array, else `False` if all elements are different. I've actually already done this question twice before but I just wanted to go back to it because I realized that there might be a better way of solving this problem plus I AM SOOOO RUSTY :sob:.

I'll go through past solutions below:

1. The first time I tackled this challenge I brute forced it by using nested loops, pretty simple implementation I just took the `length` of the list and set that as a variable then I created a nested loop where its `i+1` of the previous value, then I set a if loop to check if the index's match and boom solution completed.


```python
class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        length = len(nums);
        for i in range(length):
            for j in range(i+1, length):
                if nums[j] == nums[i]:
                    return True
        return False
```

> Time Complexity : `O(n^2)`
> 
> Space Complexity : `O(1)`

2. Lowkey this implementation I think I cheated a bit with it but writing the solution will make things clearer for me to understand. I used python `Sets` and created a set for the list however because pythons set function will not store duplicate values, it makes it super simple to tell if there has been duplicates by creating a if loop where it checks if the `Seen` set is less then the `nums` array, if it is return `True` else `False`. NOW I FULLY UNDERSTAND IT SO ITS MY FINAL SOLUTION.

```python
class Solution(object):
    def containsDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        seen = set(nums)
        if len(seen) < len(nums):
            return True
        return False
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`

3. Okay so Aleck has kindly told me of a way to optimize my previous solution, currently the code produced will always be best case `O(n)` because it needs to iterate through every single item inside the list. But if we check for duplicates everytime a new value is inputted into the set we are able to stop the process early reducing space and time complexity.


```python
class Solution(object):
    def containsDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False
        
```

> Time Complexity : `O(n) (best case O(1))`
> 
> Space Complexity : `O(n)`