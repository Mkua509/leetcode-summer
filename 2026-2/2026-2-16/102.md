---
title: "Binary Tree Level Order Traversal"
question_id: "102"
question_link: "https://leetcode.com/problems/binary-tree-level-order-traversal/description/"
difficulty: "Medium"
---

1. Given the root of a binary tree
2. Return the level order traversal of it in a nested list e.g. [[1], [2,3], [4,5,6,7]]


The best way to do this is with BFS (Breadth First Search) which comparatively to DFS which follows an LIFO structure which can be achieved in code using a stack, BFS follows the FIFO which we can use queue's for. 

The queue is a very simple concept to remember we legit just follow first in first out principles. So essentially we want to go through each different level and storing it inside a list.

To do this we can use a while loop after setting the first object in the queue as the root node, and creating a level indicator (Which is basically our index). So for as long as the queue has objects in it. It will loop through a for loop where it adds the nodes of the current level into their corresponding nested list list using the previously determined level indicator. Once one loop is complete in the for loop we can add one to the level indicator.

The process of adding to the queue involves first popping the current node and adding it into the list, then appending the left and right values of the current node into the queue then you repeat this process until you complete the process.

This code I made can be made much more effective by using dequeue which allows us to pop from the first value instead of the last value. This is because pop() automatically takes from the last value which is a O(1) operation where if we have to pop from index 0 (pop(0)) it becomes a O(n) operation per pop. Dequeue makes this process O(1) per pop.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        
        queue = []
        result = []

        if root is None:
            return result
        
        queue.append(root)
        current_level = 0

        while queue:
            length_q = len(queue)
            result.append([])

            for i in range(length_q):
                current_node = queue.pop(0)
                result[current_level].append(current_node.val)

                if current_node.left is not None:
                    queue.append(current_node.left)
                
                if current_node.right is not None:
                    queue.append(current_node.right)
            current_level += 1
        
        return result
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`

Here is the example of dequeue()

```python
from collections import deque

class Solution(object):
    def levelOrder(self, root):
        if not root:
            return []

        queue = deque([root])
        result = []

        while queue:
            level = []
            size = len(queue)

            for _ in range(size):
                node = queue.popleft()
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level)

        return result
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`

The process is still O(n) but the actual runtime efficiency decreases when we pop(0)