---
title: "Container-With-Most-Water"
question_id: "11"
question_link: "https://leetcode.com/problems/container-with-most-water/description/"
difficulty: "Medium"
---

1. Input is an integer array `height` of length `n`. There is `n` vertical lines drawn in a way that two end points are the `ith` line (meaning the index line so line 0, or 1 or 2 etc...) and end point is `(i, height[i])` the first value being index and 2nd being the lowest to highest height

2. The output is the maximum amount of water a container is able to store

3. In order to do this we need to find two lines that together with the x-axis form a container which can contain the most water. This is done by using the area equation length * width = Area 

I think the best way to approach this question with my expertise is once again using two pointer, we first set the left pointer at the start of the list and right pointer at the end of the list. Once done we can begin going down the list and seeing if the current value is larger then the current largest value, the thing to remember is that because the x value is constantly going down by one and has no difference we can assume that by choosing the column with the smallest height is always the best option to go down, this is because by moving a larger value down it will always result in a smaller value overall.

I just realized the below code that I did the calculation completely wrong, I should be taking the lowest value of the two and then using multiplication with the x value to find the actual area lol.

```python
class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """

        left = 0
        right =  len(height) - 1

        largest_area = 0

        while left < right:
            temp = height[left] * height[right] 
            if temp > largest_area:
                largest_area = temp
            if height[left] > height[right]:
                right -= 1
            elif height[right] > height[left]:
                left += 1 
            else: right -= 1

        return largest_area       

```
Okay I fixed it and it ran, I think this time around i was way less efficient in the way I coded it but it passing means that y idea was correct, the one thing I did get confused by was the temp = (right - left) part because I think I had to take one away from left in order for the index to be correct but that was wrong since it balances out.


```python
class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """

        left = 0
        right =  len(height) - 1
        largest_area = 0


        while left < right:
            temp_height = min(height[left], height[right])
            temp = (right - left) * temp_height

            if temp > largest_area:
                largest_area = temp

            if height[left] > height[right]:
                temp_height = height[right]
                right -= 1

            elif height[right] > height[left]:
                left += 1 
                temp_height = height[left]
            else: 
                temp_height = height[right]
                right -= 1

        return largest_area    
```

I feel like i've gotten a bit better at completing the two pointer questions and have definitely gotten better at solving them however still with some flaws, and probably the way I code it is not as efficient as I want it to be. Thats more of a python syntax thing though.

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`

This is a improved version below as I realized that first I don't need to set the temp_heights again that was from a previous iteration where I was setting temp_height during the checks. But I realized that it wouldn't work since it always make the temp_height 0 at the start making calculations incorrect (I initialized temp height at the top). The other thing was I don't need the extra elseif check if i just make it so that it checks if its `>=` rather then just `>` simplifying the lines by a lot.

```python
class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """

        left = 0
        right =  len(height) - 1
        largest_area = 0


        while left < right:
            temp_height = min(height[left], height[right])
            temp = (right - left) * temp_height

            if temp > largest_area:
                largest_area = temp

            if height[left] >= height[right]:
                right -= 1
            else: 
                left += 1 


        return largest_area       
```

Anyways almost new years! one more day very happy with the progress i've made now i can semi comfortably solve some leet code questions without looking at answers as much (Still have to look sometimes though but its okay.) Happy New Years Eve :))