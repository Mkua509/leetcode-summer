---
title: "Linked-List-Cycle"
question_id: "141"
question_link: "https://leetcode.com/problems/linked-list-cycle/"
difficulty: "Easy"
---

I was a bit confused at the start on how to approach this question, my main thought was what if we just iterate through the list and save the amount of numbers there are in the linked list and if the pattern begins to repeat itself we would know but like thats so so so inefficient, so i just searched up how to find a cycle in a linked list.

What I found was the `Floyd Tortoise and Hare algorithm" what the freaky is that? The core concept is pretty simple you have a slow pointer that iterates by steps of one and you have a fast pointer which iterates by two. At some point the fast and slow pointer will connect before the slow one reaches the end of the linked list, and that will be when we know there is a cycle. If the slow pointer reaches the end then we know that there is no cycle, pretty neat. 

Essentially think of it like a slow runner running around a loop against a fast one at some point the fast runner will inevitably be at the same position as the slow runner at lap them.

1. Inputs are a head which is the head of a linked list 

2. The output is a boolean of if there is a cycle in the linked list

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        
        # Floyd's Tortoise and Hare algorithm

        slow, fast = head, head

        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

            if slow == fast:
                return True
        
        return False
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`

Apparently you can also use a hash set in this its basically my previous concept but done way better. It is less effective in practice though since the space complexity requires a extra set.

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        
        seen = set()
        current = head
        
        while current:
            if current in seen:
                return True
            else:
                seen.add(current)
                current = current.next
            
        return False
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(n)`