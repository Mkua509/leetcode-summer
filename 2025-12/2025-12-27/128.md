---
title: "Longest-Consecutive-Sequence"
question_id: "128"
question_link: "https://leetcode.com/problems/longest-consecutive-sequence/description/"
difficulty: "Medium"
---

I think the problem itself isn't hard but the `O(n)` makes it extremely difficult to develop a proper solution. My first thought is if we just sort it, it would make it better but that would legit make it more then `O(n)`. I can attempt a sorted version first and see if I can pick up on any patterns we might be able to use for later.

Sorted version:

So first we have a parameter where if there is nothing in the list return 0. Else establish result as 0 and then sort the list. Set the current as first item in the list `nums` and initialize both `count` and index `i` as 0. Have a `while` loop where it keeps going until the end of the list.

We then check if the current number is equal to the current number in the list based on index. Its good to note here that the current is essentially pre guessing what the next number will be. So lets say the value before was 1 then we would set current as 2 as it should be in sequence. If it's false then we set the current value as the value which was just compared to, and reset the counter.

Now if it passes and is indeed the same number, then it would be a duplicate so it skips past it until its a unique number again. Then we add one to count and current and store into result, repeat the process until end of the list.

```python
class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        # If not num essentiall means falsy in a boolean context: If 0, None, False or a empty collection such as list, string etc...
        if not nums:
            return 0
        result = 0
        nums.sort()

        current = nums[0]
        count = 0
        i = 0

        while i < len(nums):
            if current != nums[i]:
                current = nums[i]
                count = 0
            while i < len(nums) and current == nums[i]:
                i += 1
            count += 1
            current += 1
            result = max(result, count)
        return result
```

> Time Complexity : `O(n log n)`
> 
> Space Complexity : `O(n)`

So what did I learn? Hmmmmm im not too sure exactly how do i replicate the sorting without actually sorting, well since this is in the hashing section maybe I should look into that? I think a set would work here like we would only start counting if the current number - 1 is not in the set otherwise we count forward. So it would essentially check for duplicates wwell it doesn't matter where it starts in the list.

```python
class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """



```