---
title: "Median-of-Two-Sorted-Arrays"
question_id: "4"
question_link: "https://leetcode.com/problems/median-of-two-sorted-arrays/description/"
difficulty: "Hard"
---

1. Input is two separate number lists sorted in ascending order
2. Output the median between the two lists

The question requires us to get a `O(log(n+m))` result, but currently the only way I can think of is by using sort which automatically creates an issue of `O(n log(n))` which is already larger then leetcode's requirements.

But i'll test it out anyways, first we can merge the two lists into one list then use pythons built in sorting method. Then all we have to do is to check whether or not the length is even or odd by using the `%` operation.

This will allow us to determine if we can just take the middle value of the list as the median or if we have to add the two centre values and divide to get the float value as the median. Once we complete that we can use that as the result.

In the case where we have to add the 2 centre values, because we know that floor division `//` will automatically use the smaller value as the mid point we can just add one to find the other centre value.

```python
class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        merged = nums1 + nums2
        merged.sort()
        left, right = 0, len(merged) - 1
        mid = (left + right) // 2

        # If length is Even
        if len(merged) % 2 == 0:
            result = (float(merged[mid]) + float(merged[mid + 1]))/2  
        else: 
            result = merged[mid]

        return result
```

> Time Complexity : `O((m+n)log(m+n))`
> 
> Space Complexity : `O(n + m)`

And the above solution works! The difficulty is not in the question itself its in how we can decrease the time complexity of this problem. 

### WE MUST REMOVE THE SORTING

In the case of this question a large hint that comes with it automatically is the fact that both lists are already in ascending order so it might be possible to use binary search to create a optimal solution under `O(log(m+n))` time. (`O(m + n)` is based on the two separate lists).

We might also as an bonus be able to bring the space complexity down to a `O(1)` value as we don't have to create separate lists.

Yea honestly idk how to implement its so cooked... If I every get this question in a interview know that its not because I don't know how to solve it, it makes sense when we think of it in partitions but in the grand scheme of things this is a question based on not your problem solving skills but on if you've seen this question or not.

man the best thing to do is just watch neetcode's video on it [Here](youtube.com/watch?time_continue=1322&v=q6IEA26hvXc&embeds_referring_euri=https%3A%2F%2Fneetcode.io%2F&source_ve_path=MjM4NTE)

```python
class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        A, B = nums1, nums2
        total = len(A) +len(B)
        half = total//2

        if len(B) < len(A):
            A, B = B, A
        
        left, right = 0, len(A) - 1
        while True:
            i = (left + right) // 2 # A middle
            j = half - i - 2 # B

            Aleft = A[i] if i >= 0 else float("-infinity")
            Aright = A[i + 1] if i + 1 < len(A) else float("infinity")
            Bleft = B[j] if j >= 0 else float("-infinity")
            Bright = B[j + 1] if j + 1 < len(B) else float("infinity")

            # Partition is now correct
            if Aleft <= Bright and Bleft <= Aright:
                # odd
                if total % 2:
                    return float(min(Aright, Bright))
                # even
                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0
            elif Aleft > Bright:
                right = i - 1
            else:
                left = i + 1
```

> Time Complexity : `O(log(m+n))`
> 
> Space Complexity : `O(1)`

