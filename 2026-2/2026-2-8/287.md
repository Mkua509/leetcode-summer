---
title: "Find the Duplicate Number"
question_id: "287"
question_link: "https://leetcode.com/problems/find-the-duplicate-number/description/"
difficulty: "Medium"
---

1. Input given an array of integers `nums` containing `n+1` integers where each integer is in the range [1,n] inclusive there is one repeated number

2. Return that number

- Must be O(1)
- This is technically a linked list cycle problem 

So we will use Floyd's algorithm again, so we must treat the array like a linked list, where as each index points to the next index given by its value. Because one number is duplicated, two indices will point into the same chain, creating a cycle exactly like a linked list with a loop.

The slow pointer will move one step at a time well the second pointer will move two steps because there is a cycle they will eventually meet up. Once they meet we can start a new pointer from the beginning and move both pointers one step at a time, the point where they meet again is the duplicate number (The entry point of the cycle)

```python
class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        slow, fast = 0, 0
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        
        slow2 = 0
        while true:
            slow = nums[slow]
            slow2 = nums[slow2]
            if slow == slow2:
                return slow
```

> Time Complexity : `O(n)`
> 
> Space Complexity : `O(1)`