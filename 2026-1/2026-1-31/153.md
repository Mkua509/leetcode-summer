---
title: "Find-Minimum-in-Rotated-Sorted-Array"
question_id: "153"
question_link: "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/"
difficulty: "Medium"
---

1. Given an array sorted in ascending order which is rotated between 1 and n times (e.g. the end value becomes the first value in array)

2. Return the smallest value in the array

I don't really understand how the rotation has anything to do with it? I mean the assumption we can take is that no matter what we could do this in O(n) time by just going through the entire list and finding the minimum value.

but the question does require O(log n) time what algorithm produces that? Easy binary search however binary search requires a sorted list, in this case because of the rotation it possibly makes it a little more difficult to play around with it. The assumption however that the list before any rotation was indeed already sorted in ascending order.

Well I guess that's the interesting thing about binary search as long as it was sorted before any rotated list can be used. So does that mean we have to sort the list again? Nah if we think about it this way, one part will always be sorted while the other half will always contain the rotation and the minimum value.

- If left side is sorted it cannot be there so we search the right
- If right side is sorted it cannot be there so we search the left

So we are able to thus eliminate half of the array each time and quickly find the minimum value.



```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        left, right = 0, len(nums) - 1

        while left < right:
            middle = (left + right) // 2
            if nums[middle] > nums[right]:
                left = middle + 1
            else:
                right = middle
        
        pivot = left
        left, right = 0, len(nums) - 1

        if target >= nums[pivot] and target <= nums[right]:
            left = pivot
        else:
            right = pivot - 1
        
        while left <= right:
            middle = (left + right) // 2
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle + 1
            else: 
                right = middle - 1
        
        return -1
```

> Time Complexity : `O(log n)`
> 
> Space Complexity : `O(1)`